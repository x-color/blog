[{"content":"何をするべきか 最初に結論。クロスアカウントのリソースをパラメータで受け取る際には、CloudFormationテンプレートのパラメータのタイプをString, CommaDelimitedListのどちらかにする必要がある。\nParameters: VPC: Type: String SecurityGroups: Type: CommaDelimitedList なぜStringなどしか指定できないのか CloudFormationテンプレートのパラメータとしてVPCやSecurityGroupを受け取ろうとした場合、下記のように書くことが多いと思う。\nParameters: VPC: Type: AWS::EC2::VPC::Id SecurityGroups: Type: List\u0026lt;AWS::EC2::SecurityGroup::Id\u0026gt; 単一アカウント上のリソースをパラメータに渡す際は上記がベストなのだが、クロスアカウントでリソースを参照しようとした場合、これではデプロイできない。\n実際に、上記のようなCloudFormationテンプレートを用意して、デプロイ時にパラメータに別アカウントのリソースを入力した場合、下記エラーが発生してしまう。\nParameter validation failed: parameter value xxxx for parameter name yyy does not exists. CloudFormation はデプロイ前に入力値と指定されたパラメータタイプが一致しているかなどのバリデーションを実施してくれる。 この際、パラメータにAWS固有パラメータを指定していた場合は、対象のリソースが存在するかを確認してくれるのだが、ここで指定されたリソースが存在しないと判断された場合は、上記エラーが報告される。\n「別アカウントには存在するリソースなのに、なぜないと判断される？」と考えそうになるが、そもそもあるアカウント上から許可なく別アカウントのリソースの存在有無を確認できたらおかしい。 なので、CloudFormationは実行されたアカウント内に対象のリソースが存在するかどうかを確認する。\nというわけで、クロスアカウントでリソースを参照する場合、 CloudFormationのパラメータタイプにはリソースの存在確認が入るAWS 固有パラメータ（AWS::EC2::VPC::Id, List\u0026lt;AWS::EC2::SecurityGroup::Id\u0026gt;など）ではなく、StringかCommaDelimitedListを利用する必要がある。\nなお、この話はしっかりとAWS公式のドキュメントに記載されている。\n テンプレートユーザーが異なる AWS アカウントからの入力値を入力できるようにする場合は、AWS 固有のタイプでパラメータを定義することはできません。代わりに、String タイプ (または CommaDelimitedList) タイプのパラメータを定義してください。\n パラメータ - CloudFormation\n結論 CloudFormationのパラメータバリデーションは、単一アカウントのみであればとても助かる機能であり、パラメータの入力ミスを減らしてくれる。 しかし、クロスアカウントでリソース参照する場合には使うことができないので、\nParameters: VPC: Type: AWS::EC2::VPC::Id SecurityGroups: Type: List\u0026lt;AWS::EC2::SecurityGroup::Id\u0026gt; ではなく、\nParameters: VPC: Type: String SecurityGroups: Type: CommaDelimitedList としましょう。\n","permalink":"https://x-color.github.io/blog/posts/cfn-parameter-validation-fails/","summary":"何をするべきか 最初に結論。クロスアカウントのリソースをパラメータで受け取る際には、CloudFormationテンプレートのパラメータのタイプをString, CommaDelimitedListのどちらかにする必要がある。\nParameters: VPC: Type: String SecurityGroups: Type: CommaDelimitedList なぜStringなどしか指定できないのか CloudFormationテンプレートのパラメータとしてVPCやSecurityGroupを受け取ろうとした場合、下記のように書くことが多いと思う。\nParameters: VPC: Type: AWS::EC2::VPC::Id SecurityGroups: Type: List\u0026lt;AWS::EC2::SecurityGroup::Id\u0026gt; 単一アカウント上のリソースをパラメータに渡す際は上記がベストなのだが、クロスアカウントでリソースを参照しようとした場合、これではデプロイできない。\n実際に、上記のようなCloudFormationテンプレートを用意して、デプロイ時にパラメータに別アカウントのリソースを入力した場合、下記エラーが発生してしまう。\nParameter validation failed: parameter value xxxx for parameter name yyy does not exists. CloudFormation はデプロイ前に入力値と指定されたパラメータタイプが一致しているかなどのバリデーションを実施してくれる。 この際、パラメータにAWS固有パラメータを指定していた場合は、対象のリソースが存在するかを確認してくれるのだが、ここで指定されたリソースが存在しないと判断された場合は、上記エラーが報告される。\n「別アカウントには存在するリソースなのに、なぜないと判断される？」と考えそうになるが、そもそもあるアカウント上から許可なく別アカウントのリソースの存在有無を確認できたらおかしい。 なので、CloudFormationは実行されたアカウント内に対象のリソースが存在するかどうかを確認する。\nというわけで、クロスアカウントでリソースを参照する場合、 CloudFormationのパラメータタイプにはリソースの存在確認が入るAWS 固有パラメータ（AWS::EC2::VPC::Id, List\u0026lt;AWS::EC2::SecurityGroup::Id\u0026gt;など）ではなく、StringかCommaDelimitedListを利用する必要がある。\nなお、この話はしっかりとAWS公式のドキュメントに記載されている。\n テンプレートユーザーが異なる AWS アカウントからの入力値を入力できるようにする場合は、AWS 固有のタイプでパラメータを定義することはできません。代わりに、String タイプ (または CommaDelimitedList) タイプのパラメータを定義してください。\n パラメータ - CloudFormation\n結論 CloudFormationのパラメータバリデーションは、単一アカウントのみであればとても助かる機能であり、パラメータの入力ミスを減らしてくれる。 しかし、クロスアカウントでリソース参照する場合には使うことができないので、\nParameters: VPC: Type: AWS::EC2::VPC::Id SecurityGroups: Type: List\u0026lt;AWS::EC2::SecurityGroup::Id\u0026gt; ではなく、\nParameters: VPC: Type: String SecurityGroups: Type: CommaDelimitedList としましょう。","title":"CloudFormationで別アカウントのリソースをパラメータで受け取る際にやるべきこと"},{"content":"結論 最初に結論。下記コマンドで最新版にアップデート可能\n$ sudo -E add-apt-repository ppa:git-core/ppa $ sudo apt update $ sudo apt upgrade 以前にも別の開発環境の整備中に最新版にしたことがあったのだが、手順を忘れていたので、将来の自分のためにも解決に至るまでの流れを書いておく\nGit のデフォルトブランチ名を変更したい 新たな開発環境（Ubuntu）の整備をしていた際に、「Git のデフォルトブランチの名前をmainにしないとなぁ」と思い、下記のコマンドでデフォルトブランチを変更・・・\n$ git config --global init.defaultBranch main $ git init $ git branch * master ・・・できてない。\nバージョンが古すぎて、デフォルトブランチ名の変更機能がないのかもと思い、バージョンを確認。\n$ git version git version 2.25.1 案の定、変更機能が追加される前のバージョンだった。（機能追加は、Git 2.28.0 以降） というわけで、Git のバージョンアップをしなければならない。\nUbuntu に最新版をインストール 公式のドキュメント（Download for Linux and Unix）を参考にバージョンアップを実施。\n$ sudo add-apt-repository ppa:git-core/ppa $ sudo apt update $ sudo apt upgrade 上記でバージョンアップ完了かと思いきや、最初のコマンドで下記エラーが出てしまう。\n$ sudo add-apt-repository ppa:git-core/ppa Cannot add PPA: \u0026#39;ppa:~git-core/ubuntu/ppa\u0026#39; ERROR: \u0026#39;~git-core\u0026#39; user or team does not exist. 最初は？となったが、sudo したのでプロキシ周りの設定（http_proxy, https_proxy）が引き継がれていないのでは？と気づき、環境変数を引き継いで再度実行したらエラーが解決した。\n$ sudo -E add-apt-repository ppa:git-core/ppa というわけで、下記コマンドで Git の最新版をインストールでき、無事にデフォルトブランチ名を変えることができた。\n# 最新版のGitをインストール $ sudo -E add-apt-repository ppa:git-core/ppa $ sudo apt update $ sudo apt upgrade # Gitのバージョンを確認 $ git version git version 2.31.1 # デフォルトブランチ名を変更 $ git config --global init.defaultBranch main $ git init $ git branch * main ","permalink":"https://x-color.github.io/blog/posts/install-latest-git-on-ubuntu/","summary":"結論 最初に結論。下記コマンドで最新版にアップデート可能\n$ sudo -E add-apt-repository ppa:git-core/ppa $ sudo apt update $ sudo apt upgrade 以前にも別の開発環境の整備中に最新版にしたことがあったのだが、手順を忘れていたので、将来の自分のためにも解決に至るまでの流れを書いておく\nGit のデフォルトブランチ名を変更したい 新たな開発環境（Ubuntu）の整備をしていた際に、「Git のデフォルトブランチの名前をmainにしないとなぁ」と思い、下記のコマンドでデフォルトブランチを変更・・・\n$ git config --global init.defaultBranch main $ git init $ git branch * master ・・・できてない。\nバージョンが古すぎて、デフォルトブランチ名の変更機能がないのかもと思い、バージョンを確認。\n$ git version git version 2.25.1 案の定、変更機能が追加される前のバージョンだった。（機能追加は、Git 2.28.0 以降） というわけで、Git のバージョンアップをしなければならない。\nUbuntu に最新版をインストール 公式のドキュメント（Download for Linux and Unix）を参考にバージョンアップを実施。\n$ sudo add-apt-repository ppa:git-core/ppa $ sudo apt update $ sudo apt upgrade 上記でバージョンアップ完了かと思いきや、最初のコマンドで下記エラーが出てしまう。\n$ sudo add-apt-repository ppa:git-core/ppa Cannot add PPA: \u0026#39;ppa:~git-core/ubuntu/ppa\u0026#39; ERROR: \u0026#39;~git-core\u0026#39; user or team does not exist.","title":"Proxy下のUbuntuでGitを最新版にアップデートするまで"},{"content":"タグ付けを忘れがち 普段の業務では単一の AWS アカウントを複数のプロダクトの開発に利用している。 その場合に気になってくるのがコスト。 気づいたときには「今月の請求が。。」みたいなことにならないためにも、どのプロダクトがどのリソースを利用しており、それぞれどの程度利用料が発生しているのかを把握することはとても重要。\nこのニーズを満たすために、AWS ではコスト配分タグという機能がある。これを用いることで、タグごとにリソースのコストを把握する事ができる。\n自分は普段、なにかを構築する際には CloudFormation を利用する事が多い。 コスト配分タグを最大限活用するためにも可能な限りリソースにはタグ付けをするようにしている。\nしかし、多くのリソースを構築していると一部リソースのタグ付けを忘れてしまうことがある。おかげでタグで追跡できないリソースが作成され、「これコストかかっているけど、どのプロダクトのリソース？」といったことが発生する。\n※CloudFormation スタックのタグ付けの伝搬でいいのではと最初思っていたのだが、意外とタグが伝搬されないリソースが多いので各種リソースに明示的につけるようにしている。\n忘れないために自動でテストしよう レビュー時に、テンプレートで定義されたすべてのリソースが正しくタグ付けされているかをチェックするのもいいが、そもそも「どのリソースはタグ付け可能だっけ？」となったりしてあまりにも大変。\nというわけで人の手を借りずに自動でチェックさせるために、タグ付け可能なリソースがすべて適切なタグ付けがされているかをテストするための仕組みをOpen Policy Agentを用いて実装した。\n\nちなみに、CloudFormation は高頻度で更新がかかり、随時新たなリソースの追加やタグ付けがサポートされる。 そのため、このリポジトリでは GitHub Actions を利用して、CloudFormation の更新を追いかけ、更新があるたびにポリシーファイルを更新している。 利用する場合はなるべく最新版をダウンロードして利用してもらいたい。\nテストしてみる 実際に利用してみる。今回は、タグ付け可能なリソース全てに「System」タグが付けられていることをテストする。\nなお、ここにもサンプルのポリシーや CloudFormation テンプレートを用意している。\nテストのための準備 ディレクトリ構成は下記とする\n. ├── policy │ └── deny.rego # 実際のポリシーを定義 └── templates └── template.yaml # タグ付けされていないリソースが定義されたCloudFormationテンプレート テスト対象とする CloudFormation テンプレートは下記とする。（templates/template.yaml）\nAWSTemplateFormatVersion: 2010-09-09 Parameters: VpcCidr: Type: String Resources: VPC: Type: AWS::EC2::VPC Properties: CidrBlock: !Ref VpcCidr このテンプレートでは、指定された Cidr ブロックを持つ VPC を作成するが、「System」タグを付け忘れている。\nタグ付けチェック用のポリシーファイルの作成 次にpolicy/deny.rego に 「System」タグが付与されていない場合に警告されるポリシーを定義する。\n# policy/deny.rego package policy import data.cloudformation as cfn # 「opa-cfn-tag-policy」のポリシーをインポート deny[reason] { some id rs := input.Resources[id] # *1 not cfn.resource_has_tag(rs, \u0026quot;System\u0026quot;) # *2 reason = sprintf(\u0026quot;No 'System' tag: %v\u0026quot;, [id]) # *3 } 処理の流れは下記となっている。\n 処理中のリソース名をidに格納しつつ、すべてのリソースを取得 対象のリソースが「System」タグを持っているか確認 「System」タグを持っていないリソースに対してリソース名を含んだ警告文を返す  なお、このあとのテスト時の手順に入っているが、テスト実行前に上記リポジトリ内のタグ付けされているかチェックする関数を定義しているポリシーファイルをダウンロードする必要がある。\nポリシーを用いてテスト Open Policy Agent の CLI を用いてチェックする場合は下記コマンドでチェック可能。\n# 「opa-cfn-tag-policy」リポジトリ内のタグ付けポリシーをダウンロード $ curl -L -o policy/cfn_tag.rego https://raw.githubusercontent.com/x-color/opa-cfn-tag-policy/main/policy/cfn_tag.rego # テストの実施 $ opa eval -d policy -i templates/template.yaml data.policy { \u0026#34;result\u0026#34;: [ { \u0026#34;expressions\u0026#34;: [ { \u0026#34;value\u0026#34;: { \u0026#34;deny\u0026#34;: [ \u0026#34;No \u0026#39;System\u0026#39; tag: VPC\u0026#34; # 「VPC」に「System」タグがないと報告されている ] }, \u0026#34;text\u0026#34;: \u0026#34;data.policy\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;row\u0026#34;: 1, \u0026#34;col\u0026#34;: 1 } } ] } ] } Conftestを用いるとより簡単にテストすることが可能。\n# 「opa-cfn-tag-policy」リポジトリ内のタグ付けポリシーをダウンロード $ conftest pull https://raw.githubusercontent.com/x-color/opa-cfn-tag-policy/main/policy/cfn_tag.rego # テストの実施 $ conftest test -n policy templates FAIL - templates/vpc-template.yaml - policy - No \u0026#39;System\u0026#39; tag: VPC 1 test, 0 passed, 0 warnings, 1 failure, 0 exceptions さいごに 実際に作成したテストの仕組みは CI/CD パイプラインに組み込んでおり、おかげで CloudFormation テンプレートで作成するリソースのタグ付けを忘れることがなくなった。\nタグ付け忘れで、用途不明なリソースができていてコスト管理などで困っている場合は、ぜひ利用してみてほしい。\n","permalink":"https://x-color.github.io/blog/posts/opa-cfn-tag-policy/","summary":"タグ付けを忘れがち 普段の業務では単一の AWS アカウントを複数のプロダクトの開発に利用している。 その場合に気になってくるのがコスト。 気づいたときには「今月の請求が。。」みたいなことにならないためにも、どのプロダクトがどのリソースを利用しており、それぞれどの程度利用料が発生しているのかを把握することはとても重要。\nこのニーズを満たすために、AWS ではコスト配分タグという機能がある。これを用いることで、タグごとにリソースのコストを把握する事ができる。\n自分は普段、なにかを構築する際には CloudFormation を利用する事が多い。 コスト配分タグを最大限活用するためにも可能な限りリソースにはタグ付けをするようにしている。\nしかし、多くのリソースを構築していると一部リソースのタグ付けを忘れてしまうことがある。おかげでタグで追跡できないリソースが作成され、「これコストかかっているけど、どのプロダクトのリソース？」といったことが発生する。\n※CloudFormation スタックのタグ付けの伝搬でいいのではと最初思っていたのだが、意外とタグが伝搬されないリソースが多いので各種リソースに明示的につけるようにしている。\n忘れないために自動でテストしよう レビュー時に、テンプレートで定義されたすべてのリソースが正しくタグ付けされているかをチェックするのもいいが、そもそも「どのリソースはタグ付け可能だっけ？」となったりしてあまりにも大変。\nというわけで人の手を借りずに自動でチェックさせるために、タグ付け可能なリソースがすべて適切なタグ付けがされているかをテストするための仕組みをOpen Policy Agentを用いて実装した。\n\nちなみに、CloudFormation は高頻度で更新がかかり、随時新たなリソースの追加やタグ付けがサポートされる。 そのため、このリポジトリでは GitHub Actions を利用して、CloudFormation の更新を追いかけ、更新があるたびにポリシーファイルを更新している。 利用する場合はなるべく最新版をダウンロードして利用してもらいたい。\nテストしてみる 実際に利用してみる。今回は、タグ付け可能なリソース全てに「System」タグが付けられていることをテストする。\nなお、ここにもサンプルのポリシーや CloudFormation テンプレートを用意している。\nテストのための準備 ディレクトリ構成は下記とする\n. ├── policy │ └── deny.rego # 実際のポリシーを定義 └── templates └── template.yaml # タグ付けされていないリソースが定義されたCloudFormationテンプレート テスト対象とする CloudFormation テンプレートは下記とする。（templates/template.yaml）\nAWSTemplateFormatVersion: 2010-09-09 Parameters: VpcCidr: Type: String Resources: VPC: Type: AWS::EC2::VPC Properties: CidrBlock: !Ref VpcCidr このテンプレートでは、指定された Cidr ブロックを持つ VPC を作成するが、「System」タグを付け忘れている。","title":"CloudFormationで作成するリソースのタグ付けを強制する"}]